-- Sheet 1 --


Question 1

(a)
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int): Int = {
    var i = 0; var j = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            a[0 .. i) together with b[0 .. j) are the smallest    
    //                      i + j elements in a and b considered together and 
    //            there is no element common to a[0 .. i) and b[0 .. j).
    while (i < N && j < M && a(i) != b(j)) {
        if (a(i) < b(j))
            i = i + 1
        else
            j = j + 1
    }
    a(i) // We know that an answer surely exists, so this is well behaved
}

The program may never access elements of the arrays outside safe bounds
because the only time when array accesses happen is inside the loop body, and
the loop guards together with the invariant read 0 <= i < N, 0 <= j < M.


(b) 
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int): Option[Int] = {
    var i = 0; var j = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            a[0 .. i) together with b[0 .. j) are the smallest
    //                      i + j elements in a and b considered together and 
    //            there is no element common to a[0 .. i) and b[0 .. j).
    while (i < N && j < M && a(i) != b(j)) {
       if (a(i) < b(j)) 
            i = i + 1
       else
            j = j + 1
    }
    
    // Test whether we've successfully found a common element    
    if (i < N && j < M && a(i) == b(j))
        Some(a(i))
    else
        None
}


(c)
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int,
                     c: Array[Int], L: Int): Int = {
    var i = 0; var j = 0; var k = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            0 <= k <= L and
    //            a[0 .. i), b[0 .. j) and c[0 .. k) together are the smallest
    //                      i + j + k elements in a, b and c considered together and 
    //            there is no element common to all a[0 .. i), b[0 .. j) and c[0 .. k).
    while (i < N && j < M && k < L && !(a(i) == b(j) && a(i) == c(k))) {
        if (a(i) <= b(j) && a(i) <= c(k))
            i = i + 1
        else if (b(j) <= a(i) && b(j) <= c(k))
            j = j + 1
        else
            k = k + 1
    }
    a(i) // We know that an answer surely exists, so this is well behaved
}


(d)
def smallestInCommon(as: Array[Array[Int]], n: Array[Int]): Option[Int] = {
    val m = as.size
    val i = new Array[Int](m)
    while (true) {
        // Look for the smallest "head" of the arrays to increment
        var minimum = (as(0)(i(0)), 0)
        var allEqual = true
        for (j <- 0 until m) {
            if (i(j) >= n(j)) // If one of the arrays si finished
                return None
            if (as(j)(i(j)) != as(0)(i(0)))
                allEqual = false
            if (as(j)(i(j)) < minimum._1)
                minimum = (as(j)(i(j)), j)
        }
    
        if (allEqual)
            return Some(minimum._1)
        else
            i(minimum._2) = i(minimum._2) + 1
    }
    Some(-1) // Should never reach this case
}


..........................................................................................


Question 2

(a) 
def record(f: Int => Int, emit: Int => Unit): Unit = {
    var maximum = f(1)
    emit(1)
    var n = 2

    // Invariant: 1 < n and
    //            maximum = max(f[1 .. n)) and
    //            emit was called on all records in [1 .. n),
    //            in ascending order, as required
    while (true) {
        var aux = f(n)
        if (aux > maximum) {
            maximum = aux
            emit(n)
        }
        n = n + 1
    }
}


(b)
def divisors(n: Int): Int = {
    var divs = 0
    // Invariant: 1 <= i <= n + 1 and
    //            divs = the number of divisors
    //                   of n in range [1 .. i)
    for (i <- 1 to n)
        if (n % i == 0)
            divs = divs + 1
    divs
}


(c) Since divisors(n) runs in time O(n) and record will make one call to f = divisors
for all i in [1 .. n], the total time is 1 + 2 + 3 + ... + n = n * (n + 1) / 2 = O(n^2),
so we're dealing with a quadratic growth rate.


(d) Say x is a divisor of n. Then, the only prime factors x may have are p1, p2, ..., pk.
p1's exponent in x may be any integer in range [0 .. i1] - there are (i1 + 1) such choices
p2's exponent in x may be any integer in range [0 .. i2] - there are (i2 + 1) such choices
...
pk's exponent in x may be any integer in range [0 .. ik] - there are (ik + 1) such choices

Most importantly, any combination of these choices makes for a valid divisor of n.
Therefore, by the product rule, n has (i1 + 1)(i2 + 1)...(ik + 1) divisors, as expected.


(e)
def divisors2(n: Int): Int = {
    var divs = 1
    var cpN = n
    var p = 2
    // Invariant: 2 <= p and
    //            cpN = n without all of its
    //                  prime factors < p and
    //            divs = the number of divisors
    //                   of n / cpN
    while (p <= cpN) {
        if (cpN % p == 0) { // p is prime for sure in this case
            var cnt = 1
            cpN = cpN / p
            // Invariant: cnt = the number of p's in
            //                  n / cpN's prime factorization
            while (cpN % p == 0) {
                cpN = cpN / p
                cnt = cnt + 1
            }
            divs *= (cnt + 1)
        }
    }
    divs
}


(f) The second function, divisors2, is, on average, much faster because most numbers have
a few very small prime factors which will be removed from cpN on the first few iterations
of the main while loop, thus greatly reducing the range p has to walk through, as well
as the total number of division operations.


..........................................................................................


Question 3

No supposed to be attempted, as it's part of last year's IP2 paper (which is a course
we're still to study in the term to come).


..........................................................................................


Question 4

(a)
def swap(i: Int, j: Int): Unit = {
    val aux = m(i)
    m(i) = m(j)
    m(j) = aux
}

def backswap(i: Int, j: Int, n: Int): Unit = {
    if (n > 0) {
        swap(i, j)
        backswap(i + 1, j + 1, n - 1)
    }
}


(b)
def reverse(i: Int, n: Int): Unit = {
    if (n > 1) {
        swap(i, i + n - 1)
        reverse(i + 1, n - 2)
    }
}


(c) (i)  
def rotate(i: Int, n: Int, k: Int): Unit = {
    reverse(i, n - k)
    reverse(i + n - k, k)
    reverse(i, n)
}


(ii)
def rotate(i: Int, n: Int, k: Int): Unit = {
    if (0 < k && k < n) {
        if (k < n - k) {
            backswap(i, i + n - k, k)
            rotate(i + k, n - k, k)
        }
        else {
            backswap(i, i + k, n - k)
            rotate(i, k, 2 * k - n)
        }
    }
}


(iii) Since (ii) is tail recursive, we can directly translate it
into an iterative procedure:

def rotate(_i: Int, _n: Int, _k: Int): Unit = {
    var i = _i; var n = _n; var k = _k
    while (0 < k && k < n) {
        if (k < n - k) {
            backswap(i, i + n - k, k)
            i = i + k
            n = n - k
        }
        else {
            backswap(i, i + k, n - k)
            val aux = k
            k = 2 * k - n
            n = aux
        }
    }
}


(iv) 
def rotateBy1(i: Int, n: Int): Unit = {
    val x: T = m(i + n - 1)
    for (j <- i + n - 2 to i by -1)
        m(j + 1) = m(j)
    m(i) = x
}

def rotate(i: Int, n: Int, k: Int): Unit = {
    if (k > 0) {
        rotateBy1(i, n)
        rotate(i, n, k - 1)
    }
}


(d) For simplicity, I will count reads and writes together, naming both of them
"accesses". Note that a swap operation takes 3 accesses.

     (i)   In this case each element takes part in at most 2 swap operations. Thus the
           total cost is 2 * 3 * n  = 6 * n accesses.
(ii / iii) In this case one can note that with every swap operation executed by backswap
           at least one of the two swapped elements ends up in its final position,
           meaning there can be at most n backswap swap operations overall. In turn,
           this means that the rotate procedure will use at most 3 * n access operations
           overall.
    (iv)   This is certainly the worst way to implement rotate. One rotateByOne call
           uses up exactly n + 1 access operations. This means that rotate will make
           exactly k * (n + 1) access operations, which is O(n^2) if k = O(n).


(f) This has been misplaced, it actually belongs to Question 3 above.


..........................................................................................  
-- Sheet 2 --


Question 1

(a)
def preorder(t: Tree): Unit = {
    println(t.datum)
    if (t.left != null)
        preorder(t.left)
    if (t.right != null)
        preorder(t.right)
}


(b)
class Stack {
    private val MAX = 1000 // The maximum size of the stack
    private val stk = new Array[Tree](MAX)
    private var stkSz = 0
    
    // DTI: 0 <= stkSz <= MAX
    // Abs: treeSeq = stk[0 .. stkSz)
    
    // Add t to the start (i.e. top) of the stack
    // POST: stk[stkSz - 1] = t and
    //       stk[0 .. stkSz - 1) = stk0[0 .. stkSz - 1) and 
    //       stkSz = stkSz0 + 1 
    def push(t: Tree): Unit = {
        require(stkSz < MAX)
        stk(stkSz) = t
        stkSz = stkSz + 1
    }
    
    // Remove and return the first (i.e. top) element of the stack
    // PRE:  stkSz > 0
    // POST: stkSz = stkSz0 - 1 and
    //       stk[0 .. stkSz) = stk0[0 .. stkSz) and
    //       returns stk0[stkSz0 - 1]
    def pop: Tree = {
        require(stkSz > 0)
        stkSz = stkSz - 1
        stk(stkSz)
    }
    
    // Test whether the stack is empty
    // POST: stk = stk0 and
    //       stkSz = stkSz0 and
    //       returns stkSz == 0
    def isEmpty: Boolean = (stkSz == 0)
}


(c)
def preorder(t: Tree): Unit = {
    val stk = new Stack; // A stack of trees
    var node = t
    // Invariant: We still need to print the preorder traversal of node;
    //            and for each tree t' in the stack, we still need to print
    //            the preorder traversal of t'.right (processing the trees in
    //            the stack in reverse order of that in which they've been added
    //            into the stack).
    // Variant: Define the "size" of a tree as 1 + the sum of the sizes of
    //          its children. Now, v = node.size + sum {t'.right.size: t' in stk}.
    while (!stk.isEmpty || node != null) {
        if (node != null) {
            println(node.datum)
            stk.push(node)
            node = node.left
        }
        else
            node = stk.pop.right
    }
}


The main idea is to maintain two variables, a tree "node" and a stack "stk" and
assume that everything that we've got left to print is the preorder traversal of node,
followed by the preorder traversals of the nodes in stk. Now, the main loop has two cases:

    1. If node != null, then, first of all, we need to print node's preorder traversal.
       We begin doing this by first printing node's datum field, followed by pushing node
       into the stack (to signal that we still need to print the preorder traversal of
       its right child before moving on to any other nodes in the stack) and setting
       node = node.left, to start the process of printing node's left subtree.
    2. If node == null, then we need to acquire a new node and start printing its preorder
       traversal. The only valid candidate is certainly stk.top.right, based on the order
       in which we pushed the nodes into the stack.

The code terminates because the stated variant v starts at v = t.size and decreases by
exactly one with each iteration of the main loop. By the well ordering of the natural
numbers, this can only mean that v will eventually reach 0 (in which case stk.isEmpty and
node == null certainly both hold true, so the program will exit the while loop).
       
..........................................................................................


Question 2

(a) heapAt(i) = lchild(i) < N => a(i) >= a(lchild(i)) and
                rchild(i) < N => a(i) >= a(rchild(i))

By definition, this is equivalent to:

    heapAt(i) = 2 * i + 1 < N => a(i) >= a(2 * i + 1) and
                2 * i + 2 < N => a(i) >= a(2 * i + 2)

Now, because i >= N / 2, we deduce that 2 * i + 1 >= N and 2 * i + 2 >= N, so:

    heapAt(i) = True => a(i) >= a(2 * i + 1) and
                True => a(i) >= a(2 * i + 2)

Which is equivalent to:

    heapAt(i) = True and
                True

Or,

    heapAt(i) = True

As expected.


(b) 
// Auxiliary function, swaps the values of nodes i and j
def swap(i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

// The required function
def siftDown(_n: Int, end: Int) = {
    var n = _n
    // Invariant: 0 <= n <= end <= N   and
    //            heapAt[n0 .. n)      and
    //            heapAt[n + 1 .. end) and
    //            a is a rearrangement of a0
    while (n < end) {
        val l = lchild(n); val r = rchild(n)
        if (l >= end) // If n has no valid children, then stop
            n = end
        else if (r >= end) { // If n only got a left child
            if (a(l) > a(n)) { // See if swapping n with it is necessary
                swap(n, l) // And either do the swap and continue
                n = l
            }
            else
                n = end   // Or stop, as the heap property is satisfied
        }
        else {
            if (a(l) > a(r)) { // See which of the two children has the larger value
                               // and do swaps accordingly, similar to the former case
                if (a(l) > a(n)) {
                    swap(n, l)
                    n = l
                }
                else
                    n = end
            }
            else {
                if (a(r) > a(n)) {
                    swap(n, r)
                    n = r
                }
                else
                    n = end
            }
        }
    }
}


The idea is to swap n with its son of larger value whenever !heapAt(n), stopping as soon
as heapAt(n) evaluates to true.


(c)
def heapify = {
    // Invariant: -1 <= n < N and
    //            heapAt[(n + 1) .. N) and
    //            a is a rearrangement of a0
    for (n <- (N - 1) to 0 by -1)
        siftDown(n, N)
}


(d) Consider the function parent(n) = (n + 1) / 2 - 1 such that for all 0 < n < N we have
lchild(parent(n)) = n or rchild(parent(n)) = n.
Then, because heapAt holds for all 0 < n < N, we have that a(n) <= a(parent(n)) <=
a(parent(parent(n))) <= ... <= a(0) and so a(0) is the largest element in a[0 .. end).


(e)
def heapsort = {
    heapify
    // Invariant: -1 <= n < N
    //            a is a rearrangement of a0 and
    //            a(n .. N) consists of the largest N - n - 1 elements of a0 and 
    //           heapAt[0 .. n]
    for (n <- (N - 1) to 0 by -1) {
        swap(0, n)
        siftDown(0, n)
    }
}


..........................................................................................


Question 3

(a)
class Node(val datum: Int, val next: ListNode)

class IntList(headNode: Node) {
    def this() = this(null) // The list is initially empty
    ...   
}

I've chosen not to use a dummy header node, as it mostly complicates things in this case,
so headNode will be null for an empty list and its datum will correspond to the first
element of the represented list otherwise.
I've made the default constructor take the header node as a parameter to help in writing
other methods later (e.g. tail and cons).

Now, for a suitable abstraction function, define the metafunction L(node: Node) s.t.:
    L(null) = []
    L(node) = node.datum : L(node.next)

Then,
    Abs: list = L(headNode)

(b)
// Is the list empty?
def isEmpty = headNode == null

// Return the first element of the list
def head = headNode.datum

// Returns a list containing all except the first element of the current list
def tail = new IntList(headNode.next)

// Return a new list containing x followed by the elements of the current list
def cons(x: Int) = new IntList(new Node(x, headNode))


(c)

First, define a helper function (which will also come in handy to solve (d)):


def reverse = {
    // Invariant: ans contains all elements of the list
    //            between headNode and node, exclusive, in reverse order and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList
    while (node != null) {
        ans = ans.cons(node.datum)  
        node = node.next
    }
    ans
}

def map(f: Int => Int): IntList = {
    // Invariant: ans contains all elements of the list
    //            between headNode and node, exclusive, in reverse order, with f
    //            applied to their datum before being inserted to ans and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList

    while (node != null) {
        ans = ans.cons(f(node.datum))
        node = node.next
    }

    ans.reverse // The list has been built in reverse order, so reverse it
}


(d)
def filter(p: Int => Boolean): IntList = {
    // Invariant: ans contains all elements of the list whose datum satisfies p
    //            between headNode and node, exclusive, in reverse order and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList

    while (node != null) {
        if (p(node.datum))
            ans = ans.cons(node.datum)
        node = node.next
    }

    ans.reverse // The list has been built in reverse order, so reverse it 
}


..........................................................................................


Question 4

(a)
def longestFrom(i: Int, j: Int): Int = {
    if (i < N && j < N && a(i) == a(j))
        1 + longestFrom(i + 1, j + 1)
    else
        0
}


(b)
def longestRepeated = {
    var ans(-1, -1, -1)
    for (i <- 0 until N)
        for (j <- i + 1 until N) {
            val longestFr = longestFrom(i, j)
            if (longestFr > ans._3)
                ans = (i, j, longestFr)   
        }
    ans
}

Simply iterate all (i, j) pairs with i != j (WLOG i < j) and compute the largest k such
that a[i .. (i + k)) = b[j .. (j + k)), by calling longestFrom(i, j). Record the pair
(i, j) with the largest k and return the triplet (i, j, k).

Time complexity: O(N^2 * bestk), because O(N^2) (i, j) pairs are being considered and the
                 maximum time longestFrom takes to complete is bestk + O(1).


(c) I will use standard terminology such as the suffix array and the LCP (longest common
prefix).
Consider the following (stronger) result:

If str[0 .. M) are M words, then LCP(str[i], str[j]) with 0 <= i < j < M is maximized
for an (i, j) pair such that i and j are consecutive when str is sorted in lexicographical
order.

To show this, assume WLOG that str is already sorted, then we need to show that
LCP(i, j) can only be maximum when j = i + 1. This is immediate from the observation that
LCP(i, i + 1) <= LCP(i, i + 2) <= ... <= LCP(i, M - 1), which is not hard to prove
formally. But, for an informal argument, consider how words with a common prefix form
a continuous subsequence in str and realize that, for this reason, the two words with the
largest LCP have to be consecutive in the sorted order, as expected.


(d)
def before(i: Int, j: Int) = {
    if (j >= N)
        false
    else if (i >= N)
        true
    else if (a(i) == a(j))
        before(i + 1, j + 1)
    else
        a(i) < a(j)
}

This runs in time O(bestk) worst case.

(e)
def getSuffixArray = {
    val suff = new Array[Int](Int)
    for (i <- 0 until N)
        suff(i) = i
    val orderedSuffixes = suff.sortWith(before)
    orderedSuffixes
}


(f)
def longestRepeated = {
    val suffixArray = getSuffixArray
    ans = (-1, -1, -1)
    for (i <- 0 until N - 1) {
        val longestFr = longestFrom(suffixArray(i), suffixArray(i + 1))
        if (longestFr > ans._3)
            ans = (suffixArray(i), suffixArray(i + 1), longestFr)   
    }
    ans 
}

As guided by the previous parts, we compute the suffix array of a by calling the
appropriate part (e) function and then only consider (i, i + 1) pairs, as showed to be
enough in part (c). The total complexity is O(N * bestk * log N) for the suffix array and
O(N * bestk) for the remaining checks, totaling to O(N * bestk * log N).

Note: 
There are numerous linear time algorithms for computing the suffix array, such as the
classical "mod 3" divide-and-conquer algorithm. Afterwards, the LCP's of the consecutive
entries in the suffix array are known as the "LCP array". Kasai's algorithm is an
ingenious 5 lines long algorithm for computing the LCP array in linear time with constant
additional memory.


..........................................................................................
-- Sheet 3 --


Question 1

(a)
Define Sum [j = a, j = b, expr(j)] = expr(a) + expr(a + 1) + ... + expr(b) and
       Prod[j = a, j = b, expr(j)] = expr(a) * expr(a + 1) * ... * expr(b).


def digsToInt(xs: Array[Int], bs: Array[Int]): Int = {
    // Invariant: -1 <= i < N and
    //            ans = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i+1, k = j-1, bs(k)]]
    var ans = 0
    for (i <- N - 1 to 0 by -1)
        ans = ans * bs(i) + xs(i)
    ans
}

Initialization:
i = N - 1, ans = 0, so the invariant holds true initially.

Invariant maintenance:
ans                 = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i+1, k = j-1, bs(k)]]
ans * bs(i)         = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i,   k = j-1, bs(k)]]
ans * bs(i) + xs(i) = Sum[j = i  , j = N-1, xs(j) * Prod[k = i,   k = j-1, bs(k)]]

So, by executing ans = ans * bs(i) + xs(i), i = i - 1, the invariant is maintained.

(b) 
Pre: 0 <= n < Prod[j = 0, j = N - 1, bs(j)] 
def IntToDigs(n: Int, bs: Array[Int]): Array[Int] = {
    val xs = new Array[Int](N)
    xs(0) = n
    // Invariant 1 <= i <= N + 1 and
    //           for all 0 <= j < i - 1 we have that 0 <= xs(j) < bs(j) and
    //           digsToInt(xs, bs) = n
    for (i <- 1 until N) {
        xs(i)     = xs(i - 1) / bs(i - 1)
        xs(i - 1) = xs(i - 1) % bs(i - 1)
    }
    xs
}

Initialization:
i = 1, xs(0) = n, so the invariant holds true initially.

Invariant maintenance:
Note that performing xs(i) = xs(i - 1) / bs(i - 1), xs(i - 1) = xs(i - 1) % bs(i - 1)
leaves digsToInt(xs, bs) unchanged, as it's simply turning any excess xs(i - 1) into
a smaller amount in xs(i) (e.g. informally, it's exchanging many (>= 60) seconds for fewer
(>= 1) minutes).
With this in mind, coupled with the fact that xs(i - 1) < bs(i - 1) once
xs(i - 1) %= bs(i - 1) has been executed, one can see how the invariant is being
maintained.

Now, overall correctness follows from the fact that n is bounded above (see precondition)
such that the excess left at the end in xs(N - 1) is smaller than bs(N - 1).


..........................................................................................


Question 2

(a) 
/* State: lst: [Int]
 * Init:  lst = []  */
trait ReversableBuffer {
    // Add x to the end of the buffer
    // Post: lst = lst0 ++ [x]
    def append(x: Int)
    
    // Add x to the start of the buffer
    // Post: lst = x : lst0
    def prepend(x: Int)
    
    // Remove and return the i-th element, counting from zero
    // Post: lst = take i lst0 ++ drop (i + 1) lst0 and return lst0 !! i
    def get(i: Int): Int
    
    // Reverse the contents of the buffer
    // Post: lst = reverse lst
    def rev
}


(b) Note (written afterwards): In retrospect (ii) would have worked out much neater had I
used two dummy sentinel nodes for head and tail.


(i) For implementing LLBuffer internally I will use a doubly linked list. A list node will
look like this:

class Node(val datum: Int, var prev: Node, var next: Node)   
                
I will also define the following 4 state variables:
        
var head: Node = null // The beginning and 
var tail: Node = null // the end of the Linked List 
var reversed: Boolean = false // Accounts for the reverse operations (we're basically
                              // going to use mirrored versions of all operations
                              // whenever the LLBuffer is in its reversed state)
var length: Int = 0 // Keeps track of the size of the list

I've chosen this design so that I can give reasonably simple constant time implementations
for all operations but get (which would need a different data structure for time better
than linear in the worst case).

The abstraction function, in terms of the usual L(node) metafunction:
    L(null) = []
    L(node) = node.datum : L(node.next)
    
// Abs: lst = if not reversed then L(begin) else reverse L(begin)

For the DTI, also define a B(node) metafunction:
    B(null) = []
    B(node = node.datum: B(node.prev)

// DTI: L(head) finite and
//      B(tail) finite and
//      length   = length lst and
//      reversed = the paritiy of the total number of rev function calls and
//      L(head) = reverse B(tail)


(ii)
def rev = {
    if (reversed)
        reversed = false
    else
        reversed = true
}

def prepend(x: Int) = {
    length = 1 + length
    // Edge case - empty list
    if (length == 1) {
        head = new Node(x, null, null)
        tail = head
    }
    else if (!reversed) {
        head = new Node(x, null, head)
        head.next.prev = head
    }
    else {
        tail = new Node(x, tail, null)
        tail.prev.next = tail
    }
}

def append(x: Int) = {
    length = 1 + length
    // Edge case - empty list
    if (length == 1) {
        head = new Node(x, null, null)
        tail = head
    }
    else if (reversed) {
        head = new Node(x, null, head)
        head.next.prev = head
    }
    else {
        tail = new Node(x, tail, null)
        tail.prev.next = tail
    }
}

// Ignores the "reversed" variable
// Assumes i is valid and not 0 or length - 1
def get(node: Node, i: Int): Int = {
    if (i == 1) { // Erase node.next
        val aux = node.next.datum
        length = length - 1
        node.next = node.next.next
        node.next.prev = node.next.prev.prev
        aux
    }
    else
        get(node.next, i - 1)
}

def get(_i: Int): Int = {
    var i = _i
    if (reversed)
        i = length - i - 1
    require(0 <= i && i < length)
    
    // Edge case - length = 1
    if (length == 1) {
        val aux = head.datum
        length = length - 1
        head = null
        tail = null
        return aux
    }
    // Edge case - remove head
    if (i == 0) {
        val aux = head.datum
        length = length - 1
        head = head.next
        head.prev = null
        return aux
    }
    // Edge case - remove tail
    if (i == length - 1) { 
        val aux = tail.datum
        length = length - 1
        tail = tail.prev
        tail.next = null
        return aux
    }
    get(head, i)
}


..........................................................................................


Question 3

(a)
// Pre:  a is an array of integers and
//   n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int)


(b) Helper function that swaps a(i) and a(j):
// Pre: 0 <= i, j < a.size
// Post: a(i) = a0(j) and
//       a(j) = a0(i) and
//       a(k) = a0(k) for all 0 <= k < a.size, k != i, j 
def swap(a: Array[Int], i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

Classical ternary partition subroutine:
// Pre: 0 <= l < r < a.size and
//      a(l) = value
// Post: Returns (x, y) and permutes array a[l .. r) such that:
//       All elements 0 <= k < a.size with a0(k) = value are now in [x .. y) and
//       All elements 0 <= k < a.size with a0(k) < value are now in [0 .. x) and
//       All elements 0 <= k < a.size with a0(k) > value are now in [y .. a.size)
def ternaryPartition(a: Array[Int], l: Int, r: Int, value: Int): (Int, Int) = {
    var firstEqual = l
    var lastUnexplored = r - 1 
    var i = l + 1
    // Invariant: a[l .. r) is a permutation of a0[l .. r) and
    //            a(k) = a0(k) for all k not in [l .. r)
    //            1 <= l + 1 <= i <= lastUnExplored + 1 <= r <= a.size and
    //            a[l .. firstEqual) < value and
    //            a[firstEqual .. i) = value and
    //            a(lastUnexplored .. r) > value
    while (i <= lastUnexplored) {
        if (a(i) < value) {
            swap(a, firstEqual, i)
            firstEqual = firstEqual + 1
            i = i + 1
        }
        else if (a(i) > value) {
            swap(a, i, lastUnexplored)
            lastUnexplored = lastUnexplored - 1
        }
        else
            i = i + 1
    }
    (firstEqual, lastUnexplored + 1)
}

Ternary Quicksort:
// Pre: 0 <= l < r <= a.size
// Post: Permutes a[l .. r) into non-decreasing order.
def quickSort(a: Array[Int], l: Int, r: Int): Unit = {
    if (r - l > 1) {
        val pivot = a(l) // Take a(l) to be the pivot
        val split = ternaryPartition(a, l, r, pivot) // Partition around it
        quickSort(a, l, split._1) // Sort all values < pivot
        quickSort(a, split._2, r) // Sort all values > pivot
    }
}

Interface function:
// Pre:  a is an array of integers, n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int) = {
    quickSort(a, 0, n)
}

Now, for a very formal proof of correctness one would also need to carefully show how the
invariant is being maintained inside the ternaryPartition function and apply strong
induction on r - l to show that the quickSort function always correctly sorts a[l .. r).


(c) Iterative Ternary Quicksort:
// Pre: 0 <= l < r <= a.size
// Post: Permutes a[l .. r) into non-decreasing order.
def quickSort(a: Array[Int]): Unit = {
    val q = scala.collection.mutable.Queue[(Int, Int)]()
    q.enqueue((0, a.size))
    
    // Invariant: a is a permutation of a0 and
    //            sorting each range a[l .. r) with (l, r) in q would render a sorted and
    //            any two distinct ranges corresponding to elements in q are disjoint
    // Variant:   The sum of r - l over (l, r) in q
    while (!q.isEmpty) {
        // (l, r) = q.dequeue
        val aux = q.dequeue
        val l = aux._1
        val r = aux._2
        
        // If not in base case
        if (r - l > 1) {
            val pivot = a(l) // Take a(l) to be the pivot
            val split = ternaryPartition(a, l, r, pivot) // Partition around it
            q.enqueue((l, split._1)) // Sort all values < pivot, later
            q.enqueue((split._2, r)) // Sort all values > pivot, later
        }
    }
}

Also, change the calling function appropriately:
// Pre:  a is an array of integers, n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int) = {
    quickSort(a)
}

Note: This is like doing BFS on the recursion tree.


..........................................................................................


Question 4

(a)
def contain(w: String): Boolean = {
    var node = this
    for (c <- w) {
        if (node == null)
            return false
        node = node.children(toIndex(c))
    }
    return node != null && node.complete
}


(b)
def add(w: String): Unit = {
    var node = this
    for (c <- w) {
        if (node.children(toIndex(c)) == null)
            node.children(toIndex(c)) = new Trie;
        node = node.children(toIndex(c))
    }
    node.complete = true
}


(c)
def allWords(ls: String): List[String] = {
    if (ls.length == 0) {
        if (complete)
            return List[String]("")
        else
            return List[String]()
    }
    
    var ans = List[String]()
    for (i <- 0 until ls.length) {
        val c = ls.charAt(i)
        if (children(toIndex(c)) != null) {
            val subans = children(toIndex(c)).allWords(ls.substring(0, i).concat(ls.substring(i + 1))).map(x => c.toString.concat(x))
            ans = ans ++ subans
        }
    }
    ans
}


..........................................................................................
-- Sheet 4 --


Question 1

(a)
// Helper function, swaps the values of a(i) and a(j)
def swap(i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

def partition(l: Int, r: Int, p: Int): Int = {
    // Invariant: a[l .. r) is a permutation of a0[l .. r) and
    //            a(k) = a0(k) for all k not in [l .. r) and
    //            l <= j <= i <= r and
    //            a[l .. j) < p <= a[j .. i)
    var j = l
    for (i <- l until r)
        if (a(i) < p) {
            swap(i, j)
            j = j + 1
        }
    j
}


(b) val k = partition(0, N, p)

    (i) If k < p, we know that a[0 .. k) < p, so a contains k < p values in range
        [0 .. p). Therefore, by the Pigeonhole Principle, there ought to be a missing
        value x in range [0 .. p), contained in a[0 .. k).
   (ii) If k >= p, we know that a[0 .. k) < p, so a contains k >= p values in range
        [0 .. p), meaning that a contains at most N - p values in range [p .. N], which
        is made up of N - p + 1 integers. Therefore, by the Pigeonhole Principle, there
        ought to be a missing value x in range [p .. N + 1).
   

(c)
def findMissing: Int = {
    var arrayL = 0; var arrayR = N
    var l = 0; var r = N + 1
    // Invariant: a is a permutation of a0 and
    //            one of the missing values x in a is in [l .. r) and
    //            l <= a[arrayL .. arrayR) <= r and
    //            for all 0 <= k < N not in [arrayL .. arrayR), a(k) not in [l .. r] and  
    //            arrayR - arrayL < r - l
    while (arrayL < arrayR) {
        val mid = (l + r) / 2
        val k = partition(arrayL, arrayR, mid)
        if (k - arrayL < mid - l) {
            arrayR = k
            r = mid
        }
        else {
            arrayL = k
            l = mid
        }
    }
    l
}


This simply generalizes the idea stated in part (b):
Maintain two ranges [arrayL .. arrayR) and [l .. r) such that all occurrences of
values [l .. r) in a are in a[arrayL .. arrayR). Given that arrayR - arrayL < r - l,
the Pigeonhole Principle tells that there must be an x in [l .. r) that does not occur
in a[arrayL .. arrayR). It holds true that whichever of [l .. mid) and [mid .. r) accounts
for less values in a[arrayL .. arrayR) than its length has to be the right subinterval to
continue our search into (again, by the Pigeonhole Principle).


The runtime is dominated by the partition function calls, which run in total time

   arrayR0 - arrayL0 +
   arrayR1 - arrayR1 +
   ...
 
Where (arrayLi, arrayRi) are the successive values (arrayL, arrayR) takes.
The invariant tells us that, at all times, arrayR - arrayL < r - l, so our sum is bounded
from above by

    r0 - l0 +
    r1 - l1 +
    ...
    
Where, similarly, (li, ri) are the successive values (l, r) takes.
Now, knowing that r - l is about halved (to be rigorous, round N up to the nearest power
of 2 minus 1) with every iteration of the binary search loop, we may conclude that our
sum is bounded from above by:

    (r0 - l0) * (1 + 1 / 2 + 1 / 4 + ...) = (N + 1) * 2 = O(N), as expected.


..........................................................................................


Question 2

(a)
// Invariant: 0 <= i <= N and
//            For all 0 <= k < i, rowCount(k)
//            has been correctly computed,
//            according to the definition of rowCount
for (i <- 0 until N) {
    // Invariant: 0 <= j <= N and
    //            For all 0 <= k < j, rowCount(i)(k)
    //            has been correctly computed,
    //            according to the definition of rowCount
    for (j <- 0 until N)
        if (a(i)(j)) {
            if (j > 0)
                rowCount(i)(j) = 1 + rowCount(i)(j - 1)
            else
                rowCount(i)(j) = 1
        }
}


(b) In order to see why the given formula may be used to calculate the maximum-area
all-true rectangle with the top-right corner in cell (i, j), one has to imagine iterating
over all possible down row bounds of the rectangle (i.e. k - 1 in this case). Now, with
(i, j, k) fixed, the only variable dimension of the rectangle is its left column bound, x.
x has to be picked such that a[i .. k)(x .. j] is all-true, implying, by definition, that
j - rowCount(p)(j) <= x < j, for all i <= p < k.
In other words:

(max of (j - rowCount(p)(j)) over i <= p < k) <= x < j

Or,

j - (min of rowCount(p)(j) over i <= p < k) <= x < j


Now, as we want the maximum area, set x = j - (min of rowCount(p)(j) over i <= p < k) to
get an area of (k - i) * (j - x) = (k - i) * (min of rowCount(p)(j) over i <= p < k), as
expected.

def maxRectangleAt(i: Int, j: Int): Int = {
    var minimum = N + 1 // = INF
    var ans = 0
    // Invariant: i + 1 <= k <= N + 1 and
    //            minimum = min(rowCount[i .. (k - 1))(j) and
    //            ans = max{(p - i) * min{rowCount(m)(j): i <= m < p}: i < p < k}
    for (k <- i + 1 to N) {
        if (rowCount(k - 1)(j) < minimum)
            minimum = rowCount(k - 1)(j)
        val aux = (k - i) * minimum
        if (aux > ans)
            ans = aux
    }
    ans
}


(c)
def maxRectangle = {
    var ans = 0
    for (i <- 0 until N)
        for (j <- 0 until N) {
            val ansHere = maxRectangleAt(i, j)
            if (ansHere > ans)
                ans = ansHere
        }
    ans
}

Note: There is a standard way to do this in O(N^2) time using the same rowCount array
together with a linear time algorithm for solving the maximum-area rectangle in a
histogram (the standard one consists of two stack-based computations).


.........................................................................................


Question 3

(a)
val head = new Node(Int.MinValue)
val tail = new Node(Int.MaxValue)
for (i <- 0 until NumLevels) {
    head.nexts(i) = tail
    tail.nexts(i) = null // Although hopefully this
                         // should never get used
}


(b)
def getList(node: Node, level: Int): List[Node] = {
    if (node == tail)
        List(node)
    else
        List(node) ++ getList(node.nexts(level), level)
}

// Abs: lst = getList(head, 0).map(n => n.datum)
//      (I considered the state to be a Scala List instead of a Haskell List)
// DTI: For all 0 <= i < NumLevels
//          getList(head, i).map(n => n.datum) is sorted is non-decreasing order and
//          getList(head, i) is finite and it ends with tail
//          tail.nexts(i) = null
//      For all 0 <= i < NumLevels - 1
//          if n in getList(head, i), n.nexts(i) = null => n.nexts(i + 1) = null and
//          getList(head, i + 1) is a subsequence of getList(head, i)
//      head.datum = Int.MinValue
//      tail.datum = Int.MaxValue
//      No nodes other than head and tail have their datum field set to
//          Int.MinValue or Int.MaxValue
//      For all nodes other than tail, nexts(0) != null


(c)
def findPreds(x: Int): Array[Node] = {
    var currentLevel = NumLevels - 1
    var node = head
    val ans = new Array[Node](NumLevels)
    while (currentLevel >= 0) {
        if (node.nexts(currentLevel).datum < x)
            node = node.nexts(currentLevel)
        else {
            ans(currentLevel) = node
            currentLevel = currentLevel - 1
        }
    }
    ans
}

(d)
def contains(x: Int): Boolean = {
    val aux = findPreds(x)
    val nd = aux(0).nexts(0)
    nd.datum == x
}


(e)
def add(x: Int) = {
    val aux = findPreds(x)
    val cnt = pickLevel
    val node = new Node(x)
    for (i <- 0 to cnt) {
        node.nexts(i) = aux(i).nexts(i)
        aux(i).nexts(i) = node
    }
}


(f)
def delete(x: Int) = {
    if (contains(x)) {
        val aux = findPreds(x)
        val node = aux(0).nexts(0)
        for (i <- 0 until NumLevels)
            if (node.nexts(i) != null)
                aux(i).nexts(i) = node.nexts(i)
    }   
}


.........................................................................................


Question 4

(a)
for (i <- 0 until N)
    rows(i) = List()

    
(b)
// DTI: rows.size = N and
//      for all 0 <= i < N:
//          rows(i).filter(p => p._1) is ordered in strictly
//              increasing order, with all elements in [0 .. N)
//          rows(i).filter(p => p._2) has no zero entries


(c)
def get(i: Int, j: Int): Double = {
    val aux = rows(i).filter(p => p._1 == j)
    if (aux == List())
        0.0
    else
        aux.head._2
}


(d)
def set(i: Int, j: Int, x: Double): Unit = {
    if (x != 0)
        rows(i) = rows(i).takeWhile(p => p._1 < j) ++ List((j, x)) ++
                  rows(i).dropWhile(p => p._1 <= j)
    else // Edge case
        rows(i) = rows(i).takeWhile(p => p._1 < j) ++ rows(i).dropWhile(p => p._1 <= j)
}


(e)
def scale(s: Double): SparseMatrix = {
    val ans = new SparseMatrix(N)
    if (s == 0) // Edge case, if we are nullifying the matrix
        return ans
    for (i <- 0 until N)
        for (p <- rows(i))
            ans.set(i, p._1, p._2 * s)
    ans
}


(e)
def transpose: SparseMatrix = {
    val ans = new SparseMatrix(N)
    for (i <- 0 until N)
        for (p <- rows(i))
            ans.set(p._1, i, p._2)
    ans
}


(f)
def mult(that: SparseMatrix): SparseMatrix = {
    require(N == that.N) // Check for compatibility
    val ans = new SparseMatrix(N)
    for (i <- 0 until N)
        for (j <- 0 until N) {
            // Dot product row i with column j
            var sum: Double = 0.0
            for (k <- 0 until N)
                sum = sum + get(i, k) * that.get(k, j)
            ans.set(i, j, sum)
        }
    ans
}
